# C语言嵌入汇编语法

## 1. 内嵌汇编的一般格式
GCC 的内嵌汇编一般写成如下形式：

```asm
asm volatile (
    "汇编指令模板\n\t"
    : 输出操作数列表   /* 第一个冒号后的部分 */
    : 输入操作数列表   /* 第二个冒号后的部分 */
    : clobber 列表    /* 第三个冒号后的部分 */
);
```

- **汇编指令模板**：可以是一条或多条汇编指令构成的字符串。在这个字符串中，可以使用占位符（如 `%0`、`%1` 等）来引用后面操作数列表中提供的变量。
- **输出操作数列表**：列出汇编代码将写入或修改的 C 变量。每个操作数都有一个约束，描述该变量如何与汇编代码关联。
- **输入操作数列表**：列出汇编代码需要读取的 C 变量，不会被修改。
- **Clobber 列表**：告诉编译器哪些寄存器或状态在汇编代码执行过程中可能会被修改，从而避免优化错误。

## 2. 多个内存操作数的处理

### （1）输出操作数
如果有多个输出操作数，可以按照逗号分隔列出。例如：

```asm
asm volatile(
    "指令1\n\t"
    "指令2\n\t"
    "指令3\n\t"
    : "=m"(out1), "=m"(out2)   // 两个输出，分别绑定到变量 out1 和 out2
    : /* 输入操作数 */
    : /* clobber 列表 */
);
```

这里：
- `=m` 表示输出到内存变量，`=` 表示这是写入（输出）的操作数。
- 输出操作数按照从左到右的顺序自动编号，`%0` 指代 `out1`，`%1` 指代 `out2`。

### （2）输入操作数
同理，如果有多个输入操作数，也可以列出多个，如下：

```asm
asm volatile(
    "指令1\n\t"
    "指令2\n\t"
    : /* 输出操作数 */
    : "m"(in1), "m"(in2), "m"(in3)   // 三个内存输入，分别绑定到变量 in1, in2, in3
    : /* clobber 列表 */
);
```

- 每个 `"m"` 约束表示对应操作数存放在内存中。
- 如果同时存在输出和输入操作数，则输出操作数编号先用，接着输入操作数编号。比如：
  - 输出操作数：第一个为 `%0`，第二个为 `%1`。
  - 输入操作数：第一个为 `%2`，第二个为 `%3`，依此类推。

### （3）结合多个输入和输出操作数
例如下面这个例子同时含有两个输出和两个输入操作数：

```cpp
int out1, out2;
int in1, in2;

asm volatile(
    "movl %2, %%eax\n\t"   // 将第一个输入 (in1) 移动到 eax 寄存器
    "addl %3, %%eax\n\t"   // 将第二个输入 (in2) 加到 eax 寄存器中
    "movl %%eax, %0\n\t"   // 将 eax 中的结果存入第一个输出 (out1)
    "movl %%eax, %1\n\t"   // 同时也存入第二个输出 (out2)
    : "=m" (out1), "=m" (out2)   // 输出操作数：编号 %0 和 %1
    : "m" (in1), "m" (in2)       // 输入操作数：编号 %2 和 %3
    : "eax", "memory"            // clobber：声明 eax 寄存器和内存可能被修改
);
```

这里：
- 在汇编模板中用 `%2` 引用了 `in1`，`%3` 引用了 `in2`，而 `%0` 和 `%1` 分别对应 `out1` 和 `out2`。
- 输出和输入编号是连续的，先输出后输入。

### （4）使用符号名称（Named Operands）
为了提高代码可读性，可以使用命名操作数，形式如下：

```cpp
int result;
int operand1, operand2;

asm volatile(
    "movl %[op1], %%eax\n\t"
    "addl %[op2], %%eax\n\t"
    "movl %%eax, %[res]\n\t"
    : [res] "=m" (result)              // 用 [res] 标记输出操作数
    : [op1] "m" (operand1), [op2] "m" (operand2)  // 用 [op1] 和 [op2] 标记输入操作数
    : "eax", "memory"
);
```

在模板中，`%[op1]` 表示使用标记为 `op1` 的操作数。这样能让汇编代码更直观，便于维护。

## 3. 总结与注意事项

1. **操作数编号**：
   - 如果只存在输出操作数，那么编号从 `%0` 开始依次增加。
   - 如果有输出和输入操作数，则输出操作数编号先用，输入操作数依次跟在后面。

2. **约束字符串**：
   - `"m"` 用于表示内存操作数；
   - `"=m"` 表示这是一个输出操作数，写入内存。

3. **命名操作数**：
   - 通过 `[name]` 可以为操作数取一个名字，然后在模板中使用 `%[name]` 进行引用，这样比纯数字编号更清晰。

4. **clobber 列表**：
   - 必须声明所有在汇编代码中被修改的寄存器或状态（例如 `"eax"`, `"memory"`），否则编译器可能在优化时出现问题。

5. **volatile 关键字**：
   - 如果不希望编译器对内嵌汇编进行优化（例如删除或重新排序），可以加上 `volatile` 关键字。

通过以上介绍，可以看到，当有多个内存输入和输出操作数时，只需要将每个操作数用逗号分隔地列在相应的输出或输入部分，并注意操作数在汇编模板中的引用顺序。希望这个通用指南能帮助你更好地理解和使用 GCC 的内嵌汇编语法！
