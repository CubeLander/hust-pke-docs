# lab1如何避免用户进程非法写入内核区域

在 **Lab1** 的实验中，操作系统的内核与用户进程之间的内存隔离是一个关键问题，确保用户进程不能非法访问或修改内核内存是设计中的一个重要目标。由于实验环境中没有引入 **MMU**（内存管理单元），以及 **ELF 文件** 中直接将 **虚拟地址** 当作 **物理地址** 来使用的特殊处理方式，我们需要通过显式指定链接脚本中各个段的内存区域来实现这一目标，从而避免用户进程与内核之间的内存冲突。

## 1. **内存隔离的重要性**

操作系统内核是管理硬件、提供系统服务的核心部分，它需要具有高安全性和稳定性。在没有 **MMU** 的情况下，内存保护机制不能依赖硬件来自动完成，因此需要通过 **显式的内存布局** 来防止用户进程非法访问或修改内核内存区域。如果用户进程能够直接访问内核内存，可能会导致系统崩溃、数据泄漏甚至安全漏洞。因此，确保内核与用户进程之间有明确的内存隔离是非常重要的。

## 2. **Lab1中的内存管理与链接脚本**

在 **Lab1** 中，由于实验环境中没有 **MMU**，所以系统不能通过硬件来提供虚拟地址到物理地址的映射。与此同时，ELF 文件中的段被加载到与其虚拟地址直接对应的物理地址上。为了实现内存隔离，链接脚本在指定内存布局时就需要确保内核与用户程序的地址空间分开，从而避免发生内存重叠或非法访问。

### 2.1 **链接脚本中显式指定内存区域**

在 **Lab1** 实验中，由于没有引入 **MMU**，内存管理通过链接脚本显式地指定各个段的物理地址，从而确保内核和用户进程之间的内存隔离。链接脚本中的 `SECTIONS` 指令用于控制程序各个段（如 `.text`、`.data`、`.bss`）在内存中的布局，确保它们被正确加载到指定的内存区域，并避免发生内存冲突。

#### **内核链接脚本**

内核的链接脚本明确指定了每个段的起始地址以及内存对齐方式，确保内核代码、数据和未初始化的数据段被加载到正确的物理地址中，从而保证内核的稳定性和安全性。

```ld
/* 内核链接脚本 */
OUTPUT_ARCH( "riscv" )
ENTRY( _mentry )

SECTIONS
{
  /*--------------------------------------------------------------------*/
  /* Code and read-only segment                                         */
  /*--------------------------------------------------------------------*/
  . = 0x80000000;  /* 内核代码段起始地址 */
  _ftext = .;

  /* .text: 程序代码段 */
  .text : 
  {
    *(.text)
    *(.text.*)
    *(.gnu.linkonce.t.*)
    . = ALIGN(0x1000);  /* 代码段内存对齐 */

    _trap_sec_start = .;
    *(trapsec)
    . = ALIGN(0x1000);
  }

  /* .rodata: 只读数据段 */
  .rodata : 
  {
    *(.rdata)
    *(.rodata)
    *(.rodata.*)
    *(.gnu.linkonce.r.*)
  }

  /* 结束代码和只读数据段 */
  . = ALIGN(0x1000);
  _etext = .;

  /*--------------------------------------------------------------------*/
  /* HTIF: 高级输入输出接口（单独映射一页）                       */
  /*--------------------------------------------------------------------*/
  .htif :
  {
    PROVIDE( __htif_base = . );
    *(.htif)
  }
  . = ALIGN(0x1000);

  /*--------------------------------------------------------------------*/
  /* 初始化数据段                                                     */
  /*--------------------------------------------------------------------*/
  . = ALIGN(16);
  _fdata = .;

  /* .data: 可写数据段 */
  .data : 
  {
    *(.data)
    *(.data.*)
    *(.srodata*)
    *(.gnu.linkonce.d.*)
    *(.comment)
  }

  /* 结束初始化数据段 */
  . = ALIGN(16);
  _edata = .;

  /*--------------------------------------------------------------------*/
  /* 未初始化数据段                                                   */
  /*--------------------------------------------------------------------*/
  . = .;
  _fbss = .;

  /* .bss: 未初始化的可写数据段 */
  . = .;
  _bss_start = .;
  .bss : 
  {
    *(.bss)
    *(.bss.*)
    *(.sbss*)
    *(.gnu.linkonce.b.*)
    *(COMMON)
  }

  . = ALIGN(0x1000);
  _end = .;
}
```

1. **`.text`段**：内核的程序代码段从物理地址 `0x80000000` 开始，并且采用了 `0x1000` 的对齐方式，确保程序代码段在内存中的对齐满足要求。
2. **`.rodata`段**：只读数据段紧跟着 `.text` 段，并且也应用了内存对齐。
3. **`.data`段**：初始化的数据段，起始位置在内存的 `0x81000000` 处，并采用了 `16` 字节的对齐，保证数据段的对齐方式。
4. **`.bss`段**：未初始化的数据段，采用 `0x1000` 对齐。

通过这种显式的内存布局，内核的各个段都被严格地分配到指定的物理地址区间，并且通过内存对齐方式优化了内存的使用。

#### **用户进程链接脚本**

用户进程的链接脚本则指定了程序段（如 `.text`、`.data`、`.bss`）加载到一个与内核内存区域完全隔离的区域，即从物理地址 `0x81000000` 开始。通过这种方式，用户进程的内存与内核内存互不重叠，避免了非法访问内核内存的风险。

```ld
/* 用户进程链接脚本 */
OUTPUT_ARCH( "riscv" )
ENTRY(main)

SECTIONS
{
  . = 0x81000000;  /* 用户程序起始地址 */
  . = ALIGN(0x1000);

  /* .text: 程序代码段 */
  .text : { 
    *(.text) 
  }

  . = ALIGN(16);

  /* .data: 初始化数据段 */
  .data : { 
    *(.data) 
  }

  . = ALIGN(16);

  /* .bss: 未初始化数据段 */
  .bss : { 
    *(.bss) 
  }
}
```

1. **`.text`段**：用户程序的代码段从物理地址 `0x81000000` 开始，并对齐到 `0x1000`，确保代码段在内存中的对齐。
2. **`.data`段**：用户程序的初始化数据段从 `0x81000000` 后的地址开始，并对齐到 `16` 字节。
3. **`.bss`段**：用户程序的未初始化数据段也遵循了内存对齐的要求。

这种显式分配内存的方式确保了内核和用户进程的内存区域不会重叠。例如，内核的 `.text` 段从 `0x80000000` 开始，而用户程序的 `.text` 段从 `0x81000000` 开始，两者的地址空间是分开的，因此用户进程无法访问或修改内核的内存区域。

### 2.2 **ELF文件中的虚拟地址作为物理地址**

由于在 **Lab1** 中没有引入 **MMU**，系统中的虚拟地址与物理地址是一一对应的。在加载 ELF 文件时，虚拟地址直接作为物理地址使用，不需要经过地址转换。这意味着程序中定义的虚拟地址（如 `.text` 段的起始地址）会直接映射到相应的物理内存地址。这种方式简化了内存管理，但也要求开发者通过链接脚本来显式管理内存布局，以防止出现内存冲突或非法写入。

例如，假设一个程序段的虚拟地址是 `0x81000000`，在没有 MMU 的情况下，这个地址直接对应物理内存的 `0x81000000` 地址。因此，程序段的数据会直接写入这个物理内存地址。如果用户程序试图访问或修改内核的物理地址（如 `0x80000000`），则会发生非法访问，可能导致系统崩溃或数据损坏。

## 3. **防止非法写入内核内存**

通过链接脚本中的内存布局和 **ELF 文件** 的处理方式，我们确保了内核内存区域与用户进程的内存区域严格隔离。在程序加载时，内核内存区域会被分配到特定的物理地址（如 `0x80000000`），而用户程序的内存区域会被分配到另一段地址（如 `0x81000000`）。这种内存布局确保了用户进程无法访问内核内存区域。

此外，尽管在没有 **MMU** 的情况下无法进行硬件级别的内存保护，链接脚本和 ELF 文件的设计通过明确的内存布局有效地防止了非法写入。例如，用户进程的代码和数据只会被加载到 `0x81000000` 及其之后的内存地址，试图写入内核地址的任何操作都会被阻止，或者在程序设计层面避免了这种操作的发生。

## 4. **总结**

在 **Lab1** 中，由于没有引入 **MMU**，并且 **ELF 文件** 中直接将虚拟地址当作物理地址来使用，开发者通过显式指定链接脚本中的内存区域来管理内核和用户程序的内存布局。这种方法确保了内核与用户进程的内存空间相互隔离，防止用户进程非法写入内核内存。通过这种手动管理内存布局的方式，虽然系统没有硬件支持的内存保护机制，但依然能保证内核的安全性和稳定性。这为后续引入更复杂的内存管理机制（如虚拟内存和 MMU）打下了基础。