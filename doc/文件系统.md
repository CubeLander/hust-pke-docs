# 文件系统：自顶而下理解

本篇文档通过对ramfs文件系统的不同抽象层次进行重新探讨，旨在帮助读者更好地理解代理内核中的ramfs实现。在课程实验中，ramfs文件系统由用户层、进程文件控制块、VFS、ramfs及模拟的ram磁盘几部分构成。由于自底而上的理解方式通常难以全面把握这一系统的运作，本文从文件表示形式和文件接口的不同抽象层出发，探讨ramfs在这些层级中的实现，力图通过清晰的层次结构和操作接口，以一种接近于“工作流”的形式，帮助读者更直观地理解其内部机制。

## 用户层视角
关键词：文件路径`char* path`，文件描述符`int fd`，元数据结构体指针。

其中fd是用户眼里的"文件"，是进行文件读写操作的核心。'fd'既可以表示文件，也可以表示目录，是用户文件操作函数与下层通信的统一关键字。

在调用参数中的“元数据结构体指针”，即`stat_u`向下传递的`struct istat *istat`，和`readdir_u`向下传递的`struct dir*`，它们贯穿从上层到底层的整个系统调用过程，是实际操作系统传回信息的载体。

| **接口名称**    | **功能描述**                                                                 | **关键参数**                            | **返回值说明**                     |
|------------------|-----------------------------------------------------------------------------|---------------------------------------|-----------------------------------|
| `open`           | 打开或创建文件，返回文件描述符                                                 | 路径名、标志（如读写模式）                | 文件描述符（成功）或错误码（失败）    |
| `read_u`         | 从已打开的文件中读取数据到缓冲区                                              | 文件描述符、缓冲区地址、读取字节数         | 实际读取的字节数或错误码              |
| `write_u`        | 将缓冲区数据写入已打开的文件                                                  | 文件描述符、缓冲区地址、写入字节数         | 实际写入的字节数或错误码              |
| `lseek_u`        | 调整文件读写位置（如文件头、当前位置或文件尾）                                  | 文件描述符、偏移量、基准位置（whence）     | 新的文件位置或错误码                  |
| `stat_u`         | 获取文件在内存中的元数据（如大小、修改时间等）                                   | 文件描述符、元数据结构体指针              | 操作状态码（成功/失败）               |
| `disk_stat_u`    | 直接从磁盘获取文件的持久化元数据（与`stat_u`区分缓存状态）                        | 文件描述符、元数据结构体指针              | 操作状态码                          |
| `opendir_u`      | 打开目录并返回目录流描述符                                                     | 目录路径名                             | 目录流描述符或错误码                 |
| `readdir_u`      | 读取目录中的下一个条目（子文件/子目录信息）                                      | 目录流描述符、目录条目结构体指针           | 读取状态（如是否还有条目）             |
| `closedir_u`     | 关闭已打开的目录流                                                             | 目录流描述符                           | 操作状态码                          |
| `mkdir_u`        | 创建新目录                                                                    | 目录路径名                             | 操作状态码（成功/失败）               |
| `link_u`         | 创建硬链接，使两个路径指向同一文件                                              | 源文件路径、新链接路径                   | 操作状态码                          |
| `unlink_u`       | 删除文件链接（若为最后一个链接则删除文件）                                       | 文件路径                              | 操作状态码                          |

## 系统调用层视角

概括来说，系统调用层对于用户参数做地址转化，并继续向下调用，是用户与内核具体实现之间的桥梁。

该表格与用户层表格顺序一致，成垂直映射关系，便于查看和比对。

| **接口名称**    | **功能描述**                                                              | **关键参数**                            | **返回值说明**                      |
|------------------|--------------------------------------------------------------------------|---------------------------------------|-----------------------------------|
| `sys_user_open`  | 调用系统打开文件，返回文件描述符                                            | 路径名、标志（如读写模式）                | 文件描述符（成功）或错误码（失败）   |
| `sys_user_read`  | 从已打开的文件中读取数据到缓冲区                                           | 文件描述符、缓冲区地址、读取字节数         | 实际读取的字节数或错误码             |
| `sys_user_write` | 将缓冲区数据写入已打开的文件                                               | 文件描述符、缓冲区地址、写入字节数         | 实际写入的字节数或错误码             |
| `sys_user_lseek` | 调整文件读写位置（如文件头、当前位置或文件尾）                             | 文件描述符、偏移量、基准位置（whence）     | 新的文件位置或错误码                 |
| `sys_user_stat`  | 获取文件在内存中的元数据（如大小、修改时间等）                            | 文件描述符、元数据结构体指针              | 操作状态码（成功/失败）              |
| `sys_user_disk_stat` | 直接从磁盘获取文件的持久化元数据（与`sys_user_stat`区分缓存状态）         | 文件描述符、元数据结构体指针              | 操作状态码                          |
| `sys_user_opendir` | 打开目录并返回目录流描述符                                                 | 目录路径名                             | 目录流描述符或错误码                |
| `sys_user_readdir` | 读取目录中的下一个条目（子文件/子目录信息）                               | 目录流描述符、目录条目结构体指针          | 读取状态（如是否还有条目）            |
| `sys_user_closedir` | 关闭已打开的目录流                                                        | 目录流描述符                           | 操作状态码                          |
| `sys_user_mkdir` | 创建新目录                                                                | 目录路径名                             | 操作状态码（成功/失败）              |
| `sys_user_link`  | 创建硬链接，使两个路径指向同一文件                                          | 源文件路径、新链接路径                   | 操作状态码                          |
| `sys_user_unlink` | 删除文件链接（若为最后一个链接则删除文件）                                 | 文件路径                              | 操作状态码                          |


## 进程视角

用户视角的库函数，最终会把所有参数（系统调用号，文件描述符、传入参数、缓冲区、元数据容器，etc）传入系统调用的统一接口`do_syscall`，然后`do_syscall`会进一步“分发工作”给`proc_file_management`对象（虽然C语言没有面向对象特性，但是向下继续调用的过程都是围绕它的，这也侧面体现了面向对象的设计模式）。

 **进程文件控制块（proc_file_management）** 作为系统调用文件服务中的核心，承担了文件操作的桥梁作用，是调用与回调过程的中心。它维护进程的当前工作目录和打开文件表，并通过分配文件描述符来管理用户的文件资源。它的核心工作方式是 **文件描述符fd 和 进程文件句柄struct file 的 映射关系** ， 往下进一步调用VFS层的统一接口，继续分发文件任务。

 理解进程这个"层"的重点在于，文件的形式，或者说处理文件的重心，由`文件句柄fd`转变为了`文件句柄struct file*`。
 
 VFS层统一了文件操作接口，屏蔽底层文件系统的差异（如HOSTFS和RAMFS），使得文件操作对用户（也是对进程）透明。文件的元数据管理分为内存元数据和磁盘元数据，分别通过vfs_stat和vfs_disk_stat进行处理。整个设计强调透明性、隔离性和扩展性，确保不同文件系统能够无缝交互，并支持多进程环境下的资源隔离。


### 进程文件控制块-文件操作接口

| **接口名称**      | **功能描述**                                                                 | **关键参数**                            | **返回值说明**                     |
|--------------------|-----------------------------------------------------------------------------|---------------------------------------|-----------------------------------|
| `get_opened_file`  | 根据文件描述符获取进程已打开的文件对象                                        | `fd`: 文件描述符                       | 文件结构体指针或错误               |
| `do_open`          | 打开文件并分配文件描述符，关联到进程的打开文件表                              | `pathname`: 路径名<br>`flags`: 标志位  | 文件描述符（成功）或错误码（失败）  |
| `do_read`          | 从已打开的文件中读取数据到用户缓冲区                                          | `fd`: 文件描述符<br>`buf`: 缓冲区<br>`count`: 字节数 | 实际读取字节数或错误码              |
| `do_write`         | 将用户缓冲区数据写入文件                                                      | `fd`: 文件描述符<br>`buf`: 缓冲区<br>`count`: 字节数 | 实际写入字节数或错误码              |
| `do_lseek`         | 调整文件读写偏移量                                                            | `fd`: 文件描述符<br>`offset`: 偏移量<br>`whence`: 基准位置 | 新文件位置或错误码                  |
| `do_stat`          | 获取文件在内存中的元数据（如大小、权限等）                                    | `fd`: 文件描述符<br>`istat`: 元数据结构指针 | 操作状态码（0成功，非0失败）         |
| `do_disk_stat`     | 从磁盘获取文件的持久化元数据（与内存元数据区分）                              | `fd`: 文件描述符<br>`istat`: 元数据结构指针 | 操作状态码                          |
| `do_close`         | 关闭文件并释放文件描述符                                                      | `fd`: 文件描述符                       | 操作状态码                          |
| `do_opendir`       | 打开目录并分配目录流描述符                                                    | `pathname`: 目录路径                   | 目录流描述符或错误码                |
| `do_readdir`       | 读取目录中的下一个条目（子文件/子目录信息）                                    | `fd`: 目录流描述符<br>`dir`: 目录项结构指针 | 读取状态（0成功，非0失败或结束）     |
| `do_mkdir`         | 创建新目录                                                                    | `pathname`: 目录路径                   | 操作状态码（0成功，非0失败）         |
| `do_closedir`      | 关闭目录流并释放资源                                                          | `fd`: 目录流描述符                     | 操作状态码                          |
| `do_link`          | 创建硬链接，使两个路径指向同一文件                                            | `oldpath`: 源路径<br>`newpath`: 目标路径 | 操作状态码                          |
| `do_unlink`        | 删除文件链接（若为最后一个链接则删除文件）                                     | `path`: 文件路径                      | 操作状态码                          |

---



### **附：进程文件控制块的初始化接口**
>
| **接口名称**      | **功能描述**                                             |
|------------------|---------------------------------------------------------|
| `fs_init`          | 由`s_start`调用，初始化文件系统，挂载主机文件系统（HOSTFS）和内存文件系统（RAMFS）                                                                 |
| `init_proc_file_management` | 由`alloc_process`调用，初始化进程的文件管理结构，包括当前工作目录和打开文件表                     |
---

## VFS视角

### VFS的宏观工作方式

VFS（虚拟文件系统）是操作系统中的一个关键组件，它位于操作系统的内核与具体文件系统之间，主要作用是为上层应用提供一个统一的文件操作接口，同时屏蔽底层文件系统的差异。VFS的设计使得应用程序无需关心底层文件系统的具体实现，无论是本地磁盘文件系统、内存文件系统，还是网络文件系统，VFS都能通过统一的接口进行操作。这种抽象层的引入，简化了文件操作，提高了系统的可扩展性和灵活性。

VFS在内存中维护了文件和目录的缓存，通过目录项（dentry）和虚拟inode（vinode）等数据结构来表示和管理文件。具体的目录和文件内容并不直接存储在VFS中，而是保存在底层的文件系统中。VFS通过缓存这些目录项和inode，减少了路径解析和磁盘I/O的频繁操作，提高了文件操作的性能。当应用程序请求访问文件时，VFS会首先在内存中查找相关缓存数据，如果缓存未命中，再通过底层文件系统进行操作。这种工作方式使得VFS既能提供对多种文件系统的统一支持，又能在性能上做到优化。

---

### VFS的文件表示方式

在VFS中，文件的表示方式主要通过**file**、**dentry**和**vinode**三种数据结构来实现，其中的调用关系为:`file --> dentry`，`dentry-->*parent_dentry,*dentry_inode(就是文件vinode) `,`vinode --> （properties）, *i_fs_info, *superblock, *vinode_ops`。

关于删除了dentry中的*superblock字段，详见文尾注（1）



**file**（文件项）表示一个打开的文件，是`VFS`给`proc_file_management`的回调参数。由VFS负责对`file`对象的创建和销毁，

**dentry**（目录项）是路径名到文件的映射，它包含文件的路径信息以及指向相应**vinode**的指针，作用是加速路径解析。在文件系统中，每当一个路径名被解析时，系统首先通过哈希表查找已有的dentry，如果命中，则直接返回相应的文件信息，避免了重复的路径解析。若未命中，则需要通过底层文件系统进一步查找，并将结果存储到dentry缓存中以供后续访问。

**vinode**（虚拟inode）则负责表示文件的核心元数据（作者更愿意称之为“文件控制块”），存储了文件的各种属性，如文件大小、类型、权限、所有者等。它抽象了文件系统内部的具体实现，提供一个统一的接口来处理文件内容的读写操作。每个文件都会有一个与之对应的vinode，vinode通过引用计数机制来管理文件的生命周期。当文件被打开时，相关的vinode会被加载，并随着文件的打开次数增加其引用计数，直到文件关闭时，引用计数归零，资源才会被回收。

这种dentry和vinode的组合模型不仅优化了路径解析的效率，还通过分离文件路径和文件内容的管理，提供了对文件系统的更高层次抽象，使得VFS能够统一支持多种底层文件系统，同时保持高效的资源管理和访问性能。

### VFS的核心部件

**路径解析**



### VFS的接口特点




### **VFS层文件操作接口**

| **接口名称**            | **功能描述**                                              | **关键参数**                            | **返回值说明**          |
|------------------------|---------------------------------------------------------- |---------------------------------------|-----------------------------------|
| `vfs_open`             | 打开或创建文件，关联到dentry树                              | `path`: 路径<br>`flags`: 打开标志          | 文件指针（成功）或NULL（失败）      |
| `vfs_read`             | 从文件读取数据到用户缓冲区，基于vinode的读写接口              | `file`: 文件指针<br>`buf`: 缓冲区<br>`count`: 字节数 | 实际读取字节数或错误码              |
| `vfs_write`            | 将缓冲区数据写入文件，通过viop_write调用底层文件系统          | `file`: 文件指针<br>`buf`: 缓冲区<br>`count`: 字节数 | 实际写入字节数或错误码              |
| `vfs_lseek`            | 调整文件读写偏移量，调用viop_lseek实现                       | `file`: 文件指针<br>`offset`: 偏移量<br>`whence`: 基准位置 | 新偏移量或错误码                    |
| `vfs_stat`             | 获取文件内存元数据（如inode号、大小、类型）                  | `file`: 文件指针<br>`istat`: 元数据结构指针 | 状态码（0成功，非0失败）            |
| `vfs_disk_stat`        | 从磁盘获取持久化元数据，调用viop_disk_stat                  | `file`: 文件指针<br>`istat`: 元数据结构指针 | 状态码                              |
| `vfs_close`            | 关闭文件，释放dentry引用并回收vinode（若无引用）             | `file`: 文件指针                       | 状态码                              |
| `vfs_opendir`          | 打开目录，初始化目录流缓存（如RFS的目录项链表）               | `path`: 目录路径                       | 目录文件指针或NULL                  |
| `vfs_readdir`          | 读取目录项到结构体，通过viop_readdir遍历目录内容             | `file`: 目录文件指针<br>`dir`: 目录项结构指针 | 状态码（0成功，非0失败或结束）       |
| `vfs_mkdir`            | 创建新目录，调用viop_mkdir在父目录的dentry下插入新项         | `path`: 目录路径                       | 状态码（0成功，非0失败）             |
| `vfs_closedir`         | 关闭目录流，释放缓存资源（如RFS的目录项链表）                 | `file`: 目录文件指针                    | 状态码                              |
| `vfs_link`             | 创建硬链接，通过viop_link更新父目录的dentry并关联共享vinode   | `oldpath`: 源路径<br>`newpath`: 目标路径 | 状态码                              |
| `vfs_unlink`           | 删除文件链接，调用viop_unlink减少vinode的引用计数并回收资源    | `path`: 文件路径                       | 状态码                              |








---
### 附：VFS层辅助静态函数
| **接口名称**            | **功能描述**                                              | **关键参数**                            | **返回值说明**          |
|------------------------|---------------------------------------------------------- |---------------------------------------|-----------------------------------|
| `lookup_final_dentry`  | 路径解析核心函数，通过哈希表缓存与viop_lookup逐级查找目录项    | `path`: 路径<br>`parent`: 父目录指针<br>`miss_name`: 缺失名 | dentry指针或NULL                  |
| `hash_put_dentry`      | 将dentry插入哈希表，加速后续路径查找                         | `dentry`: 目录项指针                    | 状态码                              |
| `hash_get_vinode`      | 通过超级块与inode号获取缓存的vinode，避免重复加载            | `sb`: 超级块指针<br>`inum`: inode号     | vinode指针或NULL                  |


---

### 附：VFS的初始化接口

| **接口名称**      | **功能描述**                                             |
|------------------|----------------------------------------------------------|
| `vfs_init`       | 初始化VFS层，创建dentry与vinode哈希表                      |
| `vfs_mount`      | 挂载文件系统到指定位置（根目录或默认路径）                   |

---

## 备注

### 注（1）在dentry中去除superblock成员

由于dentry可以用过vinode间接访问superblock，所以说我认为dentry中的superblock字段是多余的。在查看源代码过程中，确实没有从dentry直接引用superblock的情况，证实了我的观点。故删除了调用关系中对于dentry-->superblock的表述。

---


#### **Claude对于dentry中superblock字段的意见**

你提出了一个很好的设计问题。我认为你的直觉是正确的 - dentry 结构中的 superblock 字段确实存在冗余。

在经典的 VFS 设计中，dentry 通常不直接包含 superblock 字段，而是通过其关联的 inode 来访问 superblock。这种设计具有几个优点：

1. **减少冗余** - 同一文件系统中的所有 dentry 都共享同一个 superblock，通过 inode 间接引用可以>避免重复存储这一信息

2. **清晰的责任分离** - dentry 主要负责路径名到 inode 的映射，而 superblock 信息更适合与 inode 关联，因为 inode 代表实际文件元数据

3. **一致性维护** - 当只有一处引用 superblock 时，更容易保证数据一致性，避免同步问题

4. **内存效率** - 特别是在有大量 dentry 缓存的系统中，移除冗余字段可以节省大量内存

如果你正在考虑修改 PKE 中的 VFS 实现，将 superblock 从 dentry 结构中移除是一个合理的改进。你可以通过 `dentry->dentry_inode->sb` 这样的路径来访问 superblock，这也更符合大多数现代操作系统中 VFS 的典型设计模式。

这种修改可能需要检查代码中所有直接通过 dentry 访问 superblock 的地方，但从长远来看，会使设计更加清晰和高效。