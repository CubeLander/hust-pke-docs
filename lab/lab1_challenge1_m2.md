# lab1_challenge1对lab2中的MMU支持

## 问题概述
因为lab1_challenge1在backtrace系统调用中需要访问用户的栈空间，所以需要在内核对于用户的栈指针虚拟地址做翻译。




## 内核是如何访问用户进程的内存的

我们在访问用户态的内存时，需要通过用户页表，将用户态的内存翻译为物理地址。这个过程可以通过内核函数`user_va_to_pa`实现。

但是这随之又带来一个问题，在内核态的任何内存读写，都要再通过一次内核页表。但是内核页表中对于分配给用户的物理地址，是怎么分配的？再经过一次页表地址变换以后，还能对给定的物理地址做访问吗？

内核的页表是在kern_vm_init当中初始化的，其中将所有空闲的物理地址，都在内核页表中做了物理地址=虚拟地址的直接映射。所以说，对用户的物理地址再做一次翻译，仍然能够读写正确的物理地址。

> 这是一个作者学习过程中的疑问，如果说，在内核初始化的时候，对剩下的全部物理地址做一对一的虚拟地址映射关系，那么其中会有一些物理页被拿来当页目录，这些虚拟地址不能完全被分配，其中会不会有矛盾。
> 其实不会有矛盾，因为在page_walk中分配物理页当页目录，和在页目录中初始化这个页的映射关系是可以同时进行的，二者不会有冲突。

## 解决方案

在原本实现的基础上，对于所有用户态的访存操作，都做一次user_va_to_pa的转换即可。