# lab4_challenge2 é‡è½½æ‰§è¡Œ

## å®éªŒç›®æ ‡

å»ºç«‹`exec(exectuable path)`ç³»ç»Ÿè°ƒç”¨

## å®éªŒåŸç†

forkï¼šåˆ›å»ºä¸€ä¸ªæ–°è¿›ç¨‹ï¼Œå¤åˆ¶å½“å‰è¿›ç¨‹çš„å†…å­˜ç©ºé—´ã€æ–‡ä»¶æè¿°ç¬¦ã€å †æ ˆç­‰ï¼Œè¿”å›å€¼ä¸åŒï¼šçˆ¶è¿›ç¨‹è¿”å›æ–°è¿›ç¨‹çš„ PIDï¼Œå­è¿›ç¨‹è¿”å› 0ã€‚

execveï¼šåœ¨å½“å‰è¿›ç¨‹ä¸­åŠ è½½å¹¶æ‰§è¡Œä¸€ä¸ªæ–°çš„ç¨‹åºï¼Œæ›¿æ¢å½“å‰è¿›ç¨‹çš„å†…å­˜ç©ºé—´å’Œä¸Šä¸‹æ–‡ï¼Œä½†ä¿æŒè¿›ç¨‹IDï¼ˆPIDï¼‰ä¸å˜ã€‚æ–°ç¨‹åºç›´æ¥è¿›mainå…¥å£ã€‚

ä½ æåˆ°çš„ é‡è½½æ‰§è¡Œ å…¶å®æ˜¯æŒ‡åœ¨å·²æœ‰è¿›ç¨‹çš„ä¸Šä¸‹æ–‡ä¸­åŠ è½½æ–°ç¨‹åºã€‚è¿™å¹¶ä¸æ¶‰åŠåˆ›å»ºä¸€ä¸ªæ–°è¿›ç¨‹ï¼ˆè¿™æ˜¯ fork çš„å·¥ä½œï¼‰ï¼Œä½†åœ¨å®ç°æ—¶ï¼Œå®ƒæ˜¯æ›¿æ¢å½“å‰è¿›ç¨‹çš„å†…å­˜å’ŒçŠ¶æ€ã€‚å› æ­¤ï¼Œexecve é€šå¸¸ä¼šå’Œ fork é…åˆä½¿ç”¨ã€‚

## å†…å®¹
execä¸­éœ€è¦é‡Šæ”¾å†…å­˜ä¸­æ‰€æœ‰çš„æ—§èµ„æºï¼ˆæ‰€æœ‰æ®µï¼ŒåŒ…æ‹¬å†…æ ¸ç®¡ç†çš„æ•°æ®ç»“æ„ç­‰ï¼‰
å–æ¶ˆæŒ‚èµ·çš„ä¿¡å·å¤„ç†ç¨‹åº

è§£æå’ŒåŠ è½½elfï¼Œé‡æ–°æ‰§è¡ŒåŠ è½½ç”¨æˆ·ç¨‹åºå¹¶æ‰§è¡Œçš„è¿‡ç¨‹

åŒæ—¶pid,ppid,cwdå¯èƒ½è¢«ä¿ç•™

execå¯¹äºä¿¡å·çš„å½±å“ï¼Ÿ
åœ¨ exec ä¹‹å‰ï¼Œè¿›ç¨‹å¯èƒ½é€šè¿‡ sigprocmask è®¾å®šäº†ä¿¡å·å±è”½é›†ï¼ˆå³å“ªäº›ä¿¡å·æš‚æ—¶ä¸èƒ½è¢«å¤„ç†ï¼‰ã€‚åœ¨ exec ä¹‹åï¼Œå±è”½é›†ä¼šè¢«ä¿ç•™ï¼Œæ‰€ä»¥å¦‚æœæŸäº›ä¿¡å·åœ¨ exec ä¹‹å‰è¢«å±è”½ï¼Œåœ¨ exec ä¹‹åä»ç„¶ä¼šè¢«å±è”½ã€‚

	ä½œè€…äº‘ï¼Œæ‰€ä»¥è¯´ï¼Œè¿›ç¨‹çš„èµ„æºéœ€è¦é€šè¿‡pcbæ¥ç»Ÿä¸€ç®¡ç†


æˆ‘ä»¬éœ€è¦æ‹†å¼€è§£è€¦host elfçš„ä»£ç ã€‚

## å¤„ç†æµç¨‹

### è¿›ç¨‹ç›®å‰çš„å„ä¸ªèµ„æº

#### PCB

æ³¨é‡Šä¸­åªè®¨è®ºexecæœ‰å½±å“çš„å†…å®¹ã€‚

```c
typedef struct process_t {
  uint64 kstack;
  pagetable_t pagetable;	// éœ€è¦æ‰‹åŠ¨åšmap/unmap
  trapframe* trapframe;
  trapframe* ktrapframe;

  // added @lab1_challenge2 è¿™äº›äº‹å®ä¸Šéœ€è¦æ˜ å°„elfæ–‡ä»¶çš„debugæ®µï¼Œæœ€åä¸€å—å®ç°
  char *debugline;
  char **dir;
  code_file *file;
  addr_line *line;
  int line_count;

  uint64 user_stack_bottom;
		// éšç”¨æˆ·æ ˆå˜åŒ–çš„ï¼Œéœ€è¦é‡ç½®

  mapped_region *mapped_info;
  	// éœ€è¦æ¢æ‰é‡Œé¢çš„ç¨‹åº
  int total_mapped_region;
  // å†…å®¹æœ‰å˜åŒ–ï¼Ÿç”¨æˆ·çš„å †æ ˆå’Œä»£ç æ•°æ®éƒ½è¦é‡ç½®ï¼Œå †é‡ç½®ä¼š-1
  process_heap_manager user_heap;
	// ç”¨æˆ·å †éœ€è¦æ¸…ç©º
  uint64 pid;
  int status;
  struct process_t *parent;
  struct process_t *queue_next;	
  int tick_count;
  int sem_index;
  // 

  proc_file_management *pfiles;
  // ä¿ç•™è¿›ç¨‹çš„æ–‡ä»¶èµ„æº
  // å±€éƒ¨å˜é‡ä¸¢äº†ï¼Œå†ç”¨è¿™äº›æ–‡ä»¶èµ„æºæœ‰ä»€ä¹ˆç”¨ï¼Ÿ
  // æ¯”å¦‚è¯´ä¿ç•™ä¸çˆ¶è¿›ç¨‹é€šä¿¡çš„ç®¡é“ï¼ˆè¢«åŠ¨ï¼‰ï¼Œä¿ç•™ä»ç»ˆç«¯çš„è¾“å…¥ã€‚
  // å¯ä»¥æ‰‹åŠ¨è®¾ç½®æ–‡ä»¶æ˜¯å¦è¢«execç»§æ‰¿
  // å¦å¤–ï¼Œåœ¨è¿›ç¨‹ç»ˆæ­¢æ—¶ï¼Œä¼šå…³é—­å’Œé‡Šæ”¾è¿›ç¨‹æŒæœ‰çš„å…¨éƒ¨æ–‡ä»¶èµ„æºã€‚
  // è¿›ç¨‹å¯¹äºæ–‡ä»¶çš„ä½¿ç”¨ä¸ä¸€å®šæ˜¯å®Œå…¨äº’æ–¥çš„ï¼Œå¤šä¸ªè¿›ç¨‹å¯ä»¥åŒæ—¶è¯»ä¸€ä¸ªæ–‡ä»¶ã€‚

}process;
```

#### mapped_region
```c
// the VM regions mapped to a user process
typedef struct mapped_region {
  uint64 va;       // mapped virtual address
  uint32 npages;   // mapping_info is unused if npages == 0
  uint32 seg_type; // segment type, one of the segment_types
} mapped_region;

// types of a segment
enum segment_type {
  STACK_SEGMENT = 0,   // runtime stack segmentm from init_user_stack
  // é‡ç½®ç”¨æˆ·æ ˆ
  CONTEXT_SEGMENT, // trapframe segment, from alloc_process
  SYSTEM_SEGMENT,  // system segment,from alloc_process
  HEAP_SEGMENT,    // runtime heap segment, from init_user_heap
  // é‡ç½®ç”¨æˆ·å †
  CODE_SEGMENT,    // ELF segmentm from elf_load_segment
  // é‡ç½®ä»£ç 
  DATA_SEGMENT,    // ELF segment, from elf_load_segment
  // é‡ç½®å…¨å±€æ•°æ®æ®µ
};
```

#### process_heap_manager
```c
typedef struct process_heap_manager {
  // points to the last free page in our simple heap.
  uint64 heap_top;
  // points to the bottom of our simple heap.
  uint64 heap_bottom;

  // the address of free pages in the heap
  // uint64 free_pages_address[MAX_HEAP_PAGES];
  // the number of free pages in the heap
  // uint32 free_pages_count;
}process_heap_manager;
```




## execéœ€è¦æ¸…ç†å“ªäº›èµ„æºï¼Ÿ

### **ğŸ” `exec()` éœ€è¦æ¸…ç†å“ªäº›èµ„æºï¼Ÿä¿ç•™å“ªäº›èµ„æºï¼Ÿ**
`exec()` çš„æ ¸å¿ƒç›®æ ‡æ˜¯ **ç”¨æ–°çš„å¯æ‰§è¡Œæ–‡ä»¶æ›¿æ¢å½“å‰è¿›ç¨‹çš„ä»£ç æ®µã€æ•°æ®æ®µå’Œå †æ ˆï¼ŒåŒæ—¶å°½å¯èƒ½ä¿æŒè¿›ç¨‹çš„å…¶ä»–ç¯å¢ƒä¸å˜**ã€‚è¿™æ„å‘³ç€ï¼š
- **å¿…é¡»æ¸…ç†çš„èµ„æº**ï¼šåœ°å€ç©ºé—´ã€ä¿¡å·å¤„ç†ç¨‹åºç­‰ã€‚
- **å¿…é¡»ä¿ç•™çš„èµ„æº**ï¼šæ–‡ä»¶æè¿°ç¬¦ï¼ˆé™¤ `FD_CLOEXEC`ï¼‰ã€PIDã€çˆ¶è¿›ç¨‹å…³ç³»ç­‰ã€‚

---

## **ğŸ¯ æ€»ç»“**
| èµ„æº | `exec()` æ˜¯å¦æ¸…ç†ï¼Ÿ | å¤‡æ³¨ |
|------|------------------|------|
| **åœ°å€ç©ºé—´ï¼ˆä»£ç /æ•°æ®/å †/æ ˆï¼‰** | âœ… **å¿…é¡»æ¸…ç†** | æ—§ä»£ç å¿…é¡»é‡Šæ”¾ï¼ŒåŠ è½½æ–° ELF |
| **æ–‡ä»¶æè¿°ç¬¦ï¼ˆFDï¼‰** | ğŸ”¸ **éƒ¨åˆ†æ¸…ç†** | å…³é—­ `FD_CLOEXEC`ï¼Œä¿ç•™æ™®é€š FD |
| **ä¿¡å·å¤„ç†ç¨‹åº** | âœ… **å¿…é¡»æ¸…ç†** | `sigaction` è®¾ä¸º `SIG_DFL` |
| **ä¿¡å·å±è”½é›†** | âŒ **ä¿ç•™** | `sigprocmask` ç»§æ‰¿ |
| **è¿›ç¨‹ IDï¼ˆPIDï¼‰** | âŒ **ä¿ç•™** | `getpid()` ä¸å˜ |
| **çˆ¶è¿›ç¨‹ IDï¼ˆPPIDï¼‰** | âŒ **ä¿ç•™** | `getppid()` ä¸å˜ |
| **`wait_queue_t`** | âŒ **ä¿ç•™** | å…è®¸ `wait()` |
| **è¿›ç¨‹è°ƒåº¦ä¿¡æ¯** | âŒ **ä¿ç•™** | `priority`ã€`time_slice` ä»ç„¶æœ‰æ•ˆ |
| **å…±äº«å†…å­˜/ç®¡é“/IPC** | âŒ **ä¿ç•™** | `shm` / `pipe` ä»ç„¶æœ‰æ•ˆ |

ä½ ç°åœ¨ `exec()` é‡Œé‡åˆ°å“ªäº›èµ„æºé‡Šæ”¾çš„é—®é¢˜ï¼ŸğŸš€ğŸ”¥



## è¿›ç¨‹æŒæœ‰å“ªäº›èµ„æºï¼Ÿ

### å†…æ ¸æ€èµ„æº

PCB

ç”¨æˆ·é¡µè¡¨

ç”¨æˆ·mmèµ„æºè¡¨

ç­‰å¾…é˜Ÿåˆ—ï¼ˆæ²¡æœ‰å®ç°ï¼‰

å†…æ ¸æ ˆ

ç”¨æ¥å®ç°waitçš„ä¿¡å·é‡

å†…æ ¸ä½¿ç”¨çš„æ–‡ä»¶è¡¨

åœ¨è°ƒåº¦å™¨ä¸­çš„è°ƒåº¦çŠ¶æ€

è¿›ç¨‹é—´é€šä¿¡ï¼Œå’Œç½‘ç»œèµ„æº
å…±äº«å†…å­˜ï¼ˆshmget/shmatï¼‰ã€‚
ä¿¡å·é‡ï¼ˆsem_tï¼‰ã€‚
ç®¡é“ï¼ˆpipeï¼‰ã€‚
å¥—æ¥å­—ï¼ˆsocketï¼‰ã€‚

### ç”¨æˆ·æ€èµ„æº

æ•°æ®æ®µ

ä»£ç æ®µ

å †

æ ˆ

ç”¨æˆ·ä¿¡å·é‡